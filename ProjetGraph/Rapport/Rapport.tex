\input{header.tex}
\title{Rapport - Projet Graph}
\fancyhf{}
\lhead{\leftmark}
\lfoot{COLEAU Victor \& COUCHOUD Thomas}
\rfoot{Page~\thepage}

\begin{document}
	\maketitle
	\tableofcontents
	\chapter{Présentation du sujet}
		L'objectif de ce projet est de réaliser une librairie de classes et de fonctions permettant de manipuler des graphs. Celle-ci devra nous permettre de stocker en mémoire des graphs ainsi que leurs composants, à savoir des sommets et des arcs. De plus, il devra être possible d'effectuer des actions basiques telles qu'ajouter ou supprimer des éléments.
		
		Enfin, il devra être possible de générer des graphs en important leur structure depuis des fichiers texte externes formatés comme indiqué dans le sujet.
	
	\chapter{Architecture}
		La classe centrale de notre projet est CGraph. Celle-ci représente un graph. Y sont stockées les informations suivantes:
		\begin{itemize}
			\item Le nombre de sommets contenus dans le graph.
			\item L'indice du plus grand sommet du graph (choix expliqué par la suite).
			\item Un tableau 1D contenant des pointeurs sur les objets sommets.\\
		\end{itemize}
		De plus, cette classe contient l'ensemble des méthodes demandées telles que :
		\begin{itemize}
			\item L'ajout d'un sommet au graph.
			\item La suppression d'un sommet du graph.
			\item La vérification de l'existance d'un sommet dans le graph.
			\item L'ajout d'un arc (orienté) entre deux sommets existants.
			\item La suppression d'un arc entre deux sommets.
			\item La modification d'un arc par redirection de son sommet d'arrivé.
			\item La vérification de l'existance d'un arc dans le graph.
			\item L'ajout d'un lien (arc dans les deux sens) entre deux sommets.
			\item L'inversion du graph (invertion de tous les arcs).
			\item Le nettoyage du graph.
			\item L'affichage du graph.
			\item L'opérateur d'addition ajoutant un sommet.
			\item L'opérateur de soustraction supprimant un sommet.
			\item L'opérateur d'affectation duplicant un graph dans un autre.\\
		\end{itemize}
		
		Deux autres classes se distinguent par leur importance : CVertex (un sommet) et CArc (un arc).\\
		
		La classe CVertex contient les informations suivantes.
		\begin{itemize}
			\item L'indice du sommet.
			\item Le nombre d'arcs entrants.
			\item Un tableau 1D de pointeurs sur les arcs entrants.
			\item Le nombre d'arcs sortants.
			\item Un tableau 1D de pointeurs sur les arcs sortants.\\
		\end{itemize}
		Cette classe contient des méthodes servants principalement à modifier les arcs contenus.
		\begin{itemize}
			\item L'accesseur à l'indice du sommet.
			\item L'accesseur au nombre d'arcs entrants.
			\item L'accesseur au nombre d'arcs sortants.
			\item L'ajout (par la création) d'un arc entrant.
			\item La suppression d'un arc entrant.
			\item La modification d'un arc entrant.
			\item L'ajout (par la création) d'un arc sortant.
			\item La suppression d'un arc sortant.
			\item La modification d'un arc sortant.
			\item La vérification de l'existance d'un arc entrant.
			\item La vérification de l'existance d'un arc sortant.
			\item L'affichage des arcs entrants.
			\item L'affichage des arcs sortants.
			\item L'invertion des arcs.
			\item L'opérateur d'affectation duplicant le contenu d'un sommet dans un autre.\\
		\end{itemize}
		
		La classe CArc ne contient que peu d'informations.
		\begin{itemize}
			\item L'indice du sommet pointé par l'arc.\\
		\end{itemize}
		Elle contient les méthodes suivantes :
		\begin{itemize}
			\item L'accesseur à l'indice de l'arc.
			\item Le mutateur de l'indice de l'arc.
			\item L'opérateur d'affectation duplicant un arc.\\
		\end{itemize}
		
		%TODO parser Thomas
		Afin de pouvoir lire des graphs externes au programme, nous avons implémenté une classe statique CGraphParser. Cette dernière lira un fichier texte du format indiqué et renverra au choix, une matrice ou une matrice carrée. Pour réaliser cela, cette dernière s'appuie sur une énumération et une structure. L'énumération eMatrixType permet de faire la transition entre le type de la matrice écrite dans le fichier et le type du language. La structure sMatrixInfo stocke de manière temporaire les informations de la matrice lues dans le fichier. 
		
		\img{../../classDiagram.png}{Diagramme de classes}{0.55}{90}
		
	\chapter{Choix de codage}
		Avant tout chose, nous avons prit la décision de créer un fichier nommé "utils.h". Celui-ci contient des macros permettant de compiler sous Visual Studio et un système Unix (utilisation des méthodes propres à chaque compilateur). De plus, il contient un certain nombre de macros utilitaires, notamment MMALLOC et RREALLOC allouant l'espace mémoire demandé tout en vérifiant le bon déroulement.
	
		Le choix de créer une classe CSquareMatrix héritée de CMatrix vient des nombreuses opérations mathématiques propres aux matrices carrées. Nous aurions put implémenter celles-ci directement dans la classe des matrices quelconques mais nous aurions alors du vérifier à chaque appel si la matrice avait le même nombre de lignes et de colonnes et lever une exception en cas d'échec.
		Grâce à ce choix, nous évitons un grand nombre de vérifications sans pour autant géner les calculs normaux puisque des matrices carrées sont aussi des matrices simples et peuvent donc être multipliées, transposées, etc..
		
		
	
		%Parser why sMatrixInfo?
		Dans le parser, nous utilisons une structure SMatrixInfo. Celle-ci contient temporairement les informations d'une matrice. Nous en avons l'utilité lors de la création de nos matrices après lecture. En effet, si nous stockions directement les informations lues dans un objet matrice, nous ne pourrions pas faire la différence entre une matrice quelconque et une matrice carrée. Cela est du au fait que l'objet doit être créé avant la lecture mais que nous avons besoin des informations lues pour définir le type d'objet à créer. La structure sert donc à vérifier si une matrice est carrée ou non pour ensuite instancier l'objet approprié.
	
	\chapter{Tests effectués}
		Afin de pouvoir valider le fonctionnement de notre code, nous avons réalisé de nombreux tests. Certains ont été réalisés manuellement mais un bon nombre d'entre eux ont été écrits sous forme de "test unitaires". Ceux-ci sont présents dans les fichiers CXXXTest.cpp qui vont respectivement tester leur classe XXX.
		
		Nous sommes conscients que les tests sont très minimalistes et ne couvrent pas tout, cependant cela est déjà un bon départ pour vérifier un fonctionnement "normal".
		
		Commençons par CExceptionUnit:
		\begin{itemize}
			\item Tests des différents constructeur impliquant l'ID de l'exception ainsi que des getters et setters de celui-ci.
			\item Tests des différents constructeur impliquant le message de l'exception ainsi que des getters et setters de celui-ci.\\
		\end{itemize}
		Ceux-ci sont très généralistes mais couvrent relativement bien les différentes utilisations d'un objet de cette classe.
		
		Intéressons-nous maintenant à CMatrixUnit:
		\begin{itemize}
			\item Tests des différents constructeurs ainsi que des getters concernant le nombre de lignes et le nombre de colonnes.
			\item Tests des getters et setters sur les valeurs de la matrice.
			\item Tests des différentes opérations:
			\begin{itemize}
				\item[$\bullet$] Transposée d'une matrice.
				\item[$\bullet$] Multiplication par un coefficient.
				\item[$\bullet$] Division par un coefficient.
				\item[$\bullet$] Division par le coefficient 0 renvoyant une exception.
				\item[$\bullet$] Test d'égalité de matrices.
				\item[$\bullet$] Test d'affectation de matrices.
				\item[$\bullet$] Test de l'opérateur $\left(\right)$
				\item[$\bullet$] Test de l'opérateur $\left(\right)$ avec coordonnées invalides renvoyant une exception.
				\item[$\bullet$] Test de la somme de deux matrices.
				\item[$\bullet$] Test de la soustraction de deux matrices.
				\item[$\bullet$] Test du produit de deux matrices.
				\item[$\bullet$] Test du produit de deux matrices incompatibles renvoyant une exception.
				\item[$\bullet$] Test de l'opérateur *= avec un coefficient.
				\item[$\bullet$] Test de l'opérateur *= avec une matrice.
				\item[$\bullet$] Test de l'opérateur *= avec une matrice incompatible renvoyant une exception.
				\item[$\bullet$] Test de l'opérateur /= avec un coefficient.
				\item[$\bullet$] Test de l'opérateur /= avec un coefficient 0 renvoyant une exception.\\
			\end{itemize}
		\end{itemize}
		
		Ces tests nous semblent assez complets sur les matrices. Cependant chaque test n'est effectué qu'une seule fois ce qui peut mettre en douter l'efficacité de celui-ci.
		
		Passons ensuite aux tests contenus dans CSquareMatrixUnit:
		\begin{itemize}
			\item Test des différents constructeurs ainsi que des getters concernant la dimension de la matrice.
			\item Tests des getters et setters sur les valeurs de la matrice.
			\item Tests des différentes opérations:
			\begin{itemize}
				\item[$\bullet$] Test du calcul du déterminant.
				\item[$\bullet$] Test du calcul d'une comatrice.
				\item[$\bullet$] Test du calcul d'une matrice inverse.
				\item[$\bullet$] Test du calcul d'une matrice inverse avec déterminant nul, renvoyant une exception.
				\item[$\bullet$] Calcul de la puissance d'une matrice.\\
			\end{itemize}
		\end{itemize}
		
		Enfin les derniers tests sont effectués dans CMatrixParserUnit:
		\begin{itemize}
			\item Test de la lecture d'un fichier.
			\item Test de la lecture d'un ficher avec un type non supporté, renvoyant une exception.
			\item Test de la lecture d'un fichier en tant que matrice carrée.
			\item Test de la lecture d'un fichier en tant que matrice carrée avec une matrice non carrée, renvoyant une exception.
		\end{itemize}
	
	\chapter{Conseils d'utilisation}
	Le programme a été conçu et compilé de sorte que l'exécutable puisse prendre en arguments des fichiers sources de matrice formatés comme défini dans le sujet.
	
	Suite à cela, il va exécuter les instructions suivantes :
	\begin{itemize}
		\item Demander à l'utilisateur un coefficient.
		\item Calculer et afficher les résultats de la multiplication de chaque matrice par le coefficient précédent.
		\item Calculer et afficher les résultats de la division de chaque matrice par le coefficient précédent.
		\item Calculer et afficher le résultat de la somme de toutes les matrices.
		\item Calculer et afficher le résultat de la somme alternée de toutes les matrices.
		\item Calculer et afficher le résultat du produit de toutes les matrices. \\
	\end{itemize}
	Si une exception est levée pour n'importe lequel de ces points, le message d'erreur est affiché et le programme s'arrête instantanément.\\
	
	Pour toute autre utilisation, la classe Main devra être modifier par l'utilisateur, deux choix sont possibles.
	
	Une matrice peut être lue d'un fichier grâce aux fonctions statiques "PMTXreadMatrix" et "PMTXreadSquareMatrix" prenant chacune en paramètre le chemin relatif d'un fichier source de matrice. La première renverra un objet de la classe CMatrix quelles que soient les réelles dimensions de la matrice lue alors que la seconde créera une matrice carrée (ou lèvera une exception si la matrice lue n'est pas carrée). Les deux lèveront des exceptions si un problème survient lors de la lecture.
	
	D'une seconde manière, une matrice peut être créée directement depuis son constructeur mais celle-ci sera remplie de 0. Nous pouvons par la suite utiliser le setter adéquat pour modifier chaque valeur de la matrice a sa guise. A savoir qu'un constructeur identité est disponible pour les matrices carrées.

	Pour toute information supplémentaire sur les méthodes, se référer aux cartouches d'entête présents dans les fichiers .h.
\end{document}
